{"ast":null,"code":"import { asap } from '@react-dnd/asap';\nimport { invariant } from '@react-dnd/invariant';\nimport { addSource, addTarget, removeSource, removeTarget } from '../actions/registry.js';\nimport { validateSourceContract, validateTargetContract, validateType } from '../contracts.js';\nimport { HandlerRole } from '../interfaces.js';\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js';\nfunction getNextHandlerId(role) {\n  const id = getNextUniqueId().toString();\n  switch (role) {\n    case HandlerRole.SOURCE:\n      return `S${id}`;\n    case HandlerRole.TARGET:\n      return `T${id}`;\n    default:\n      throw new Error(`Unknown Handler Role: ${role}`);\n  }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n  switch (handlerId[0]) {\n    case 'S':\n      return HandlerRole.SOURCE;\n    case 'T':\n      return HandlerRole.TARGET;\n    default:\n      throw new Error(`Cannot parse handler ID: ${handlerId}`);\n  }\n}\nfunction mapContainsValue(map, searchValue) {\n  const entries = map.entries();\n  let isDone = false;\n  do {\n    const {\n      done,\n      value: [, value]\n    } = entries.next();\n    if (value === searchValue) {\n      return true;\n    }\n    isDone = !!done;\n  } while (!isDone);\n  return false;\n}\nexport class HandlerRegistryImpl {\n  addSource(type, source) {\n    validateType(type);\n    validateSourceContract(source);\n    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n    this.store.dispatch(addSource(sourceId));\n    return sourceId;\n  }\n  addTarget(type, target) {\n    validateType(type, true);\n    validateTargetContract(target);\n    const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n    this.store.dispatch(addTarget(targetId));\n    return targetId;\n  }\n  containsHandler(handler) {\n    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n  }\n  getSource(sourceId) {\n    let includePinned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n    const isPinned = includePinned && sourceId === this.pinnedSourceId;\n    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n    return source;\n  }\n  getTarget(targetId) {\n    invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n    return this.dropTargets.get(targetId);\n  }\n  getSourceType(sourceId) {\n    invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n    return this.types.get(sourceId);\n  }\n  getTargetType(targetId) {\n    invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n    return this.types.get(targetId);\n  }\n  isSourceId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.SOURCE;\n  }\n  isTargetId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.TARGET;\n  }\n  removeSource(sourceId) {\n    invariant(this.getSource(sourceId), 'Expected an existing source.');\n    this.store.dispatch(removeSource(sourceId));\n    asap(() => {\n      this.dragSources.delete(sourceId);\n      this.types.delete(sourceId);\n    });\n  }\n  removeTarget(targetId) {\n    invariant(this.getTarget(targetId), 'Expected an existing target.');\n    this.store.dispatch(removeTarget(targetId));\n    this.dropTargets.delete(targetId);\n    this.types.delete(targetId);\n  }\n  pinSource(sourceId) {\n    const source = this.getSource(sourceId);\n    invariant(source, 'Expected an existing source.');\n    this.pinnedSourceId = sourceId;\n    this.pinnedSource = source;\n  }\n  unpinSource() {\n    invariant(this.pinnedSource, 'No source is pinned at the time.');\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n  }\n  addHandler(role, type, handler) {\n    const id = getNextHandlerId(role);\n    this.types.set(id, type);\n    if (role === HandlerRole.SOURCE) {\n      this.dragSources.set(id, handler);\n    } else if (role === HandlerRole.TARGET) {\n      this.dropTargets.set(id, handler);\n    }\n    return id;\n  }\n  constructor(store) {\n    this.types = new Map();\n    this.dragSources = new Map();\n    this.dropTargets = new Map();\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n    this.store = store;\n  }\n}","map":{"version":3,"sources":["../../src/classes/HandlerRegistryImpl.ts"],"names":["asap","invariant","addSource","addTarget","removeSource","removeTarget","validateSourceContract","validateTargetContract","validateType","HandlerRole","getNextUniqueId","getNextHandlerId","role","id","toString","SOURCE","TARGET","Error","parseRoleFromHandlerId","handlerId","mapContainsValue","map","searchValue","entries","isDone","done","value","next","HandlerRegistryImpl","types","Map","dragSources","dropTargets","pinnedSourceId","pinnedSource","store","type","source","sourceId","addHandler","dispatch","target","targetId","containsHandler","handler","getSource","includePinned","isSourceId","isPinned","get","getTarget","isTargetId","getSourceType","getTargetType","delete","pinSource","unpinSource","set"],"mappings":"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","sourcesContent":["import { asap } from '@react-dnd/asap'\nimport { invariant } from '@react-dnd/invariant'\nimport type { Store } from 'redux'\n\nimport {\n\taddSource,\n\taddTarget,\n\tremoveSource,\n\tremoveTarget,\n} from '../actions/registry.js'\nimport {\n\tvalidateSourceContract,\n\tvalidateTargetContract,\n\tvalidateType,\n} from '../contracts.js'\nimport type {\n\tDragSource,\n\tDropTarget,\n\tHandlerRegistry,\n\tIdentifier,\n\tSourceType,\n\tTargetType,\n} from '../interfaces.js'\nimport { HandlerRole } from '../interfaces.js'\nimport type { State } from '../reducers/index.js'\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js'\n\nfunction getNextHandlerId(role: HandlerRole): string {\n\tconst id = getNextUniqueId().toString()\n\tswitch (role) {\n\t\tcase HandlerRole.SOURCE:\n\t\t\treturn `S${id}`\n\t\tcase HandlerRole.TARGET:\n\t\t\treturn `T${id}`\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown Handler Role: ${role}`)\n\t}\n}\n\nfunction parseRoleFromHandlerId(handlerId: string) {\n\tswitch (handlerId[0]) {\n\t\tcase 'S':\n\t\t\treturn HandlerRole.SOURCE\n\t\tcase 'T':\n\t\t\treturn HandlerRole.TARGET\n\t\tdefault:\n\t\t\tthrow new Error(`Cannot parse handler ID: ${handlerId}`)\n\t}\n}\n\nfunction mapContainsValue<T>(map: Map<string, T>, searchValue: T) {\n\tconst entries = map.entries()\n\tlet isDone = false\n\tdo {\n\t\tconst {\n\t\t\tdone,\n\t\t\tvalue: [, value],\n\t\t} = entries.next()\n\t\tif (value === searchValue) {\n\t\t\treturn true\n\t\t}\n\t\tisDone = !!done\n\t} while (!isDone)\n\treturn false\n}\n\nexport class HandlerRegistryImpl implements HandlerRegistry {\n\tprivate types: Map<string, SourceType | TargetType> = new Map()\n\tprivate dragSources: Map<string, DragSource> = new Map()\n\tprivate dropTargets: Map<string, DropTarget> = new Map()\n\tprivate pinnedSourceId: string | null = null\n\tprivate pinnedSource: any = null\n\tprivate store: Store<State>\n\n\tpublic constructor(store: Store<State>) {\n\t\tthis.store = store\n\t}\n\n\tpublic addSource(type: SourceType, source: DragSource): string {\n\t\tvalidateType(type)\n\t\tvalidateSourceContract(source)\n\n\t\tconst sourceId = this.addHandler(HandlerRole.SOURCE, type, source)\n\t\tthis.store.dispatch(addSource(sourceId))\n\t\treturn sourceId\n\t}\n\n\tpublic addTarget(type: TargetType, target: DropTarget): string {\n\t\tvalidateType(type, true)\n\t\tvalidateTargetContract(target)\n\n\t\tconst targetId = this.addHandler(HandlerRole.TARGET, type, target)\n\t\tthis.store.dispatch(addTarget(targetId))\n\t\treturn targetId\n\t}\n\n\tpublic containsHandler(handler: DragSource | DropTarget): boolean {\n\t\treturn (\n\t\t\tmapContainsValue(this.dragSources, handler) ||\n\t\t\tmapContainsValue(this.dropTargets, handler)\n\t\t)\n\t}\n\n\tpublic getSource(sourceId: string, includePinned = false): DragSource {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\tconst isPinned = includePinned && sourceId === this.pinnedSourceId\n\t\tconst source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId)\n\t\treturn source\n\t}\n\n\tpublic getTarget(targetId: string): DropTarget {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.dropTargets.get(targetId) as DropTarget\n\t}\n\n\tpublic getSourceType(sourceId: string): Identifier {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\treturn this.types.get(sourceId) as Identifier\n\t}\n\n\tpublic getTargetType(targetId: string): Identifier | Identifier[] {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.types.get(targetId) as Identifier | Identifier[]\n\t}\n\n\tpublic isSourceId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.SOURCE\n\t}\n\n\tpublic isTargetId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.TARGET\n\t}\n\n\tpublic removeSource(sourceId: string): void {\n\t\tinvariant(this.getSource(sourceId), 'Expected an existing source.')\n\t\tthis.store.dispatch(removeSource(sourceId))\n\t\tasap(() => {\n\t\t\tthis.dragSources.delete(sourceId)\n\t\t\tthis.types.delete(sourceId)\n\t\t})\n\t}\n\n\tpublic removeTarget(targetId: string): void {\n\t\tinvariant(this.getTarget(targetId), 'Expected an existing target.')\n\t\tthis.store.dispatch(removeTarget(targetId))\n\t\tthis.dropTargets.delete(targetId)\n\t\tthis.types.delete(targetId)\n\t}\n\n\tpublic pinSource(sourceId: string): void {\n\t\tconst source = this.getSource(sourceId)\n\t\tinvariant(source, 'Expected an existing source.')\n\n\t\tthis.pinnedSourceId = sourceId\n\t\tthis.pinnedSource = source\n\t}\n\n\tpublic unpinSource(): void {\n\t\tinvariant(this.pinnedSource, 'No source is pinned at the time.')\n\n\t\tthis.pinnedSourceId = null\n\t\tthis.pinnedSource = null\n\t}\n\n\tprivate addHandler(\n\t\trole: HandlerRole,\n\t\ttype: SourceType | TargetType,\n\t\thandler: DragSource | DropTarget,\n\t): string {\n\t\tconst id = getNextHandlerId(role)\n\t\tthis.types.set(id, type)\n\t\tif (role === HandlerRole.SOURCE) {\n\t\t\tthis.dragSources.set(id, handler as DragSource)\n\t\t} else if (role === HandlerRole.TARGET) {\n\t\t\tthis.dropTargets.set(id, handler as DropTarget)\n\t\t}\n\t\treturn id\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}